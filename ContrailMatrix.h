/*
*                              ■ 航迹矩阵类库  @ContrailMatrixLibrary ■                               
*                                                                                                     
****************************************************************************************************
*																									
*    注意：本库设计在C++环境中。
*    该库是为@ContrailGraphicLibrary而设计的，用于为图形的几何变换提供基础的线性代数计算所设计的引擎。                                      
*    该矩阵类库实现了矩阵的线性运算、乘除运算、求逆运算以及伴随矩阵的构造与行列式求值等功能。                                                 
*    															 			                              
*    Version:	build_18.8.21                                               Creation date:2018.8.12                              
*                                                                                                                              
****************************************************************************************************
*                                                                                                     
*	1: 本库仅用作学习交流，未经作者允许不能用于其他用途！            
*	2: 修改本库后保留原作者名单。                               																  
*	3: 技术群：453967739                                           
*                                                               
*	作者保留一切权利                                                   
*	Copyright(C) Contrail Company           			                    
*	All rights reserved          
****************************************************************************************************
<author> 

1:ひこうき(Contrail)
****************************************************************************************************
<local log>

2018.8.18(author ひこうき): 加入8bit变量位计数表与位映射表来优化行列式运算
2018.8.21(author ひこうき): 由于时间因素，该库暂不加入哈希表来优化高阶行列式运算
****************************************************************************************************/

#ifndef CONTRAIL_MATRIX_LIB_H
#define CONTRAIL_MATRIX_LIB_H

/* @brief 
	Matrix memory source select enumeration */
#define	HEAP_MEMORY	  0	/*!< Using heap memory	*/
#define	STACK_MEMORY  1	/*!< Using stack memory	*/

/* @brief 
	Matrix memory source configuration 
   @description
    This definition can choose to store the data generated by the operation in the heap or stack area */
#define SET_MEMORY_SOURCE STACK_MEMORY

#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	#define MAXIMUM_MATRIX 400
	#define _CML_NULL_ (ELEM_TYPE *)0 
#else 
	#include <malloc.h>
	#define _CML_NULL_ (ELEM_TYPE *)0
#endif

#ifndef __cplusplus
	#error "ContrailMatrixLibrary: 在编译本库时你必须使用C++编译器, 或者你需要在.CPP文件中包含本头文件！"
#endif


/***************************************************************************************************
*	@defgroup matrix class library declaration area
*	@{
***************************************************************************************************/

/* @brief 
	contrail's matrix arithmetic class library name encapsulation */
namespace CONTRAIL_MATRIX
{
/* @CONTRAIL MATRIX LIBRARY:
	Declaration of determinant operations */
#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>	
#else 
	template <class ELEM_TYPE>
#endif
	class determinant
	{
	protected:
	#if (SET_MEMORY_SOURCE == STACK_MEMORY)
		ELEM_TYPE elemArray
		[(determinant_size_row*determinant_size_col > MAXIMUM_MATRIX) ? 0 : determinant_size_row*determinant_size_col];
	#else 
		ELEM_TYPE * elemArray;
	#endif

		int detSize;
		int shiftInputPtr;

	public:
	#if (SET_MEMORY_SOURCE == STACK_MEMORY)
		determinant(ELEM_TYPE *dDArray = _CML_NULL_) :
		detSize(determinant_size_row>determinant_size_col? determinant_size_row: determinant_size_col),
		shiftInputPtr(0)
		{determinantImport(dDArray);}
	#else
		determinant(int determinant_size_row, int determinant_size_col, ELEM_TYPE *dDArray = _CML_NULL_) :
		detSize(determinant_size_row>determinant_size_col ? determinant_size_row : determinant_size_col),
		shiftInputPtr(0)
		{
			elemArray = (ELEM_TYPE *)malloc(determinant_size_row * determinant_size_col * sizeof(ELEM_TYPE));
			if (dDArray)
			determinantImport(dDArray);
		}
	#endif	

		~determinant()
		{
		#if (SET_MEMORY_SOURCE == HEAP_MEMORY)
			free(elemArray);
		#endif			
		}

	/* @brief
		Operator overloading of the determinant */
		void operator=(determinant & det);
		bool operator==(determinant & det);
		inline ELEM_TYPE* operator[](int cols) { return &elemArray[cols*detSize]; };
		inline operator ELEM_TYPE() { return getDeterminantValue(); }
		inline determinant & operator<<(ELEM_TYPE elem)
		{
			elemArray[shiftInputPtr++] = elem;
			shiftInputPtr %= determinant_size_row * determinant_size_col;
			return *this;
		}
		inline determinant & operator,(ELEM_TYPE elem) { return operator<<(elem); }
	/* @brief
		operation function declare of the determinant */
		inline void determinantImport(ELEM_TYPE *dDArray)
		{
			int detLength = detSize * detSize;
			for (int cnt(0); dDArray && cnt < detLength; cnt++)
			{elemArray[cnt] = dDArray[cnt];}
		}
		inline int getDetSize() { return detSize; };

		void detRowSwap(int rows_s, int rows_d);
		void detColSwap(int cols_s, int cols_d);

		void detRowScalarMultiply(int rows, ELEM_TYPE num);
		void detColScalarMultiply(int cols, ELEM_TYPE num);

		void detRowScalarDivide(int rows, ELEM_TYPE num);
		void detColScalarDivide(int cols, ELEM_TYPE num);

		void detRowAdd(int rows_s, int rows_d);
		void detColAdd(int cols_s, int cols_d);

		ELEM_TYPE getAlgebraicComplement(int rows, int cols);
		ELEM_TYPE getDeterminantValue();

	#if (SET_MEMORY_SOURCE == STACK_MEMORY)	
		void getTransposedDeterminant(determinant<ELEM_TYPE, determinant_size_row, determinant_size_col> & retDet);

		void getComplementMinor(int rows, int cols, determinant<ELEM_TYPE, determinant_size_row - 1, determinant_size_col - 1> & retDet);

		template <typename friendtype, int friendRows, int friendCols>
		friend void constructLookAheadList(determinant<friendtype, friendRows, friendCols> & det);

		template <typename friendtype, int friendRows, int friendCols>
		friend friendtype detACCoreOperator(determinant<friendtype, friendRows, friendCols> & det, int rows, int cols);
	#else
		void getTransposedDeterminant(determinant<ELEM_TYPE> & retDet);

		void getComplementMinor(int rows, int cols, determinant<ELEM_TYPE> & retDet);
		
		template <typename friendtype>
		friend void constructLookAheadList(determinant<friendtype> & det);

		template <typename friendtype>
		friend friendtype detACCoreOperator(determinant<friendtype> & det,int rows,int cols);
	#endif
	};
		
		
/* @CONTRAIL MATRIX LIBRARY:
	Declaration of matrix operations */

#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int matrix_size_row,int matrix_size_col>	
	class matrix : public determinant<ELEM_TYPE,matrix_size_row,matrix_size_col>
#else 
	template <class ELEM_TYPE>
	class matrix : public determinant<ELEM_TYPE>
#endif
	{
	private:
		typedef struct _MATRIX_DES_
		{
			int matSizeRow;
			int matSizeCol;
			ELEM_TYPE * pElemArray;

			_MATRIX_DES_(int m_matSizeRow, int m_matSizeColumn, ELEM_TYPE * m_pElemArray):
			matSizeRow(m_matSizeRow), matSizeCol(m_matSizeColumn), pElemArray(m_pElemArray){}
		}MATRIX_DES;
		typedef void * MATRIX;

		MATRIX_DES matrixDescription;
		MATRIX pMatrixDescription;
	public:	
	#if (SET_MEMORY_SOURCE == STACK_MEMORY)
		matrix(ELEM_TYPE *dDArray = _CML_NULL_) :
		matrixDescription(matrix_size_row, matrix_size_col, elemArray),
		pMatrixDescription((MATRIX)&matrixDescription),
		determinant<ELEM_TYPE,matrix_size_row,matrix_size_col>(dDArray){}; 
	#else
		matrix(int matrix_size_row,int matrix_size_col,ELEM_TYPE *dDArray = _CML_NULL_):
		matrixDescription(matrix_size_row, matrix_size_col, elemArray),
		pMatrixDescription((MATRIX)&matrixDescription),
		determinant<ELEM_TYPE>(matrix_size_row, matrix_size_col, dDArray){};
	#endif			
		
	/* @brief 
		Operator overloading of the matrix */
		inline operator MATRIX(){return pMatrixDescription;}
		inline ELEM_TYPE* operator[](int rows){return &this->elemArray[rows*matrixDescription.matSizeCol];}
		inline matrix & operator<<(ELEM_TYPE elem)
		{
			matrixDescription.pElemArray[shiftInputPtr++] = elem;
			shiftInputPtr %= matrix_size_row * matrix_size_col;
			return *this;
		}
		inline matrix & operator,(ELEM_TYPE elem) { return operator<<(elem); }
		inline void operator=(matrix & mat)
		{
			if(mat.detSize == detSize)
			matrixImport(mat.elemArray);
		}
		inline bool operator==(matrix & mat)
		{
			if (mat.detSize == detSize)
			{
				for (int cnt(0); cnt < detSize; cnt++)
				{
					if (mat.elemArray[cnt] != elemArray[cnt])
						return false;
				}return true;
			}return false;
		}
		
	/* @brief 
		compute overloading of the matrix */	
		void matScalarMultiply(ELEM_TYPE num);
		void matScalarDivide(ELEM_TYPE num);
		bool matMultiply(MATRIX mulMat, MATRIX retMat);
		bool matAdd(MATRIX addMat);
		bool matSub(MATRIX subMat);

	/* @brief 
		operation function declare of the matrix */
		void matRowScalarMultiply(int rows, ELEM_TYPE num);
		void matRowScalarDivide(int rows, ELEM_TYPE num);
		void matRowSwap(int rows_s, int rows_d);
		void matRowAdd(int rows_s, int rows_d);

		inline int getMatSizeRow() { return matrixDescription.matSizeRow; }
		inline int getMatSizeCol() { return matrixDescription.matSizeCol; }
		inline void matrixImport(ELEM_TYPE *dDArray)
		{
			for(int cnt(0) ; dDArray && cnt < matrixDescription.matSizeRow *matrixDescription.matSizeCol ; cnt ++)
				(this->elemArray)[cnt] = dDArray[cnt];
		}
		
	#if (SET_MEMORY_SOURCE == STACK_MEMORY)
		bool getDeterminant(determinant<ELEM_TYPE,matrix_size_row,matrix_size_col> & retDet);
		bool getInverseMatrix(MATRIX retMat);
		bool getAdjointMatrix(MATRIX retMat);
		bool getTransposeMatrix(MATRIX retMat);
	#else 
		bool getDeterminant(determinant<ELEM_TYPE> & retDet);
		bool getInverseMatrix(MATRIX retMat);
		bool getAdjointMatrix(MATRIX retMat);
		bool getTransposeMatrix(MATRIX retMat);
	#endif
	};

	inline int _COL(int cols){return cols - 1 ;};
	inline int _ROW(int rows){return rows - 1 ;};
}

/** 
  * @}
  */


/***************************************************************************************************
*	@defgroup determinant class library definition area
*	@{
***************************************************************************************************/

/* @CONTRAIL DETERMINANT LIBRARY:
	Definition of determinant class */
namespace CONTRAIL_MATRIX
{
/* @brief:
	8Bit variable digital count table
   @description:
	Use table lookups to increase time efficiency */
const unsigned char uint8_count_table[256]=
{ 
	0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
	1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,
	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
	2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,
	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
	3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,
	4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8
};

/* @brief:
	8Bit variable bit table
   @description:
	Use table lookups to increase time efficiency */
const unsigned char uint8_bit_table[129]=
{ 
	0,0,1,0,2,0,0,0,3,0,0,0,0,0,0,0,
	4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	7 
};

/* @brief:
	Define the friend function of the determinant class*/

#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <typename friendtype,int friendRows,int friendCols>
	void constructLookAheadList(determinant<friendtype,friendRows,friendCols> & det)
#else
	template <typename friendtype>
	void constructLookAheadList(determinant<friendtype> * det)
#endif
	{
/*		int listPtr(0),basePc(det.detSize - 2);
		if(det.pLookAheadList)
		{
			for(int cnt(1); cnt < det.detSize; cnt ++)
			{
				for(int cnt2(1) ; cnt2 < det.detSize - cnt + 1 ; cnt2 ++)
				{
		 			det.pLookAheadList[listPtr ++] = 
			 		det.elemArray[basePc] * det.elemArray[basePc + cnt2 * det.detSize + (friendtype)1] -
	     			det.elemArray[basePc + (friendtype)1] * det.elemArray[basePc + cnt2 * det.detSize];
				}
				basePc = (det.detSize - (friendtype)2) + cnt*det.detSize;
			}
		}*/	
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)	
	template <typename friendtype,int friendRows,int friendCols>
	friendtype detACCoreOperator(determinant<friendtype,friendRows,friendCols> & det,int rows,int cols)
#else
	template <typename friendtype>
	friendtype detACCoreOperator(determinant<friendtype> & det,int rows,int cols)
#endif
	{
	typedef unsigned char mapType;  
	#define mappingUintLength_bit  (sizeof(mapType)*8)
	#if (SET_MEMORY_SOURCE == STACK_MEMORY)	
		#define mappingArrayLength_byte (int)(friendRows/mappingUintLength_bit + (friendRows%mappingUintLength_bit != 0))	
		static mapType lineMapping[mappingArrayLength_byte] = {0};
	#else
		#define mappingArrayLength_byte (int)(det.detSize/mappingUintLength_bit + (det.detSize%mappingUintLength_bit != 0))	
		static mapType * lineMapping(NULL);

		if(!lineMapping)	
		lineMapping = (mapType *)calloc(mappingArrayLength_byte,sizeof(mapType));
	#endif

		friendtype AlgebraicC = 0;
		lineMapping[rows/mappingUintLength_bit] |= 1 << rows%mappingUintLength_bit;
		
		if(cols >= det.detSize - 2)
		{
			int pElemAddr_A = cols + rows * det.detSize;
			int pElemAddr_B(0);		

			for(;lineMapping[pElemAddr_B] == (mapType)0xFF &&
 			pElemAddr_B < mappingArrayLength_byte ; pElemAddr_B ++);
		
			mapType tmp(0);
			if(pElemAddr_B == mappingArrayLength_byte - 1 && det.detSize % mappingUintLength_bit)
			{
				tmp = lineMapping[pElemAddr_B] | 
				((mapType)0xFF << (det.detSize % mappingUintLength_bit));
			}
			else tmp = lineMapping[pElemAddr_B];
			 
			tmp = uint8_bit_table[(mapType)(~tmp)];
			pElemAddr_B = (pElemAddr_B * mappingUintLength_bit + tmp) * det.detSize + cols;
			
			if(pElemAddr_B < pElemAddr_A)
			{
				int swapt = pElemAddr_A;
				pElemAddr_A = pElemAddr_B;
				pElemAddr_B = swapt;
			}
			
			AlgebraicC = (det.elemArray[pElemAddr_A] * det.elemArray[pElemAddr_B + 1])
		  	- (det.elemArray[pElemAddr_A + 1] * det.elemArray[pElemAddr_B]) ;	
		}
		else
		{
			unsigned int cnt(0), acc(0);
			friendtype currElem = det.elemArray[(det.detSize * rows) + cols];

			for( ; cnt < cols/mappingUintLength_bit ; cnt ++)
			{acc += uint8_count_table[lineMapping[cnt]];}	

			acc += uint8_count_table[lineMapping[cnt] & 
			((mapType)0xFF >> (mappingUintLength_bit - (rows % mappingUintLength_bit)))];	

			currElem *= ((rows - acc) & 1)?-1:1;
			cols++;
			
			if(currElem) 
			for(int cnt(0),dst = (cols >= det.detSize - 2)?1:det.detSize - cols;
		 	cnt < dst ; cnt ++)
			{	
				for(int cnt(0) ; cnt < det.detSize ; cnt ++)
		 		{
 					rows = (rows + 1) % det.detSize;
		 			if(!(lineMapping[rows/mappingUintLength_bit] & ((mapType)0x01 << rows)))
		 				break;	
				}
				
				if(!(cols - 1))
				AlgebraicC += detACCoreOperator(det,rows,cols);
				else AlgebraicC += detACCoreOperator(det,rows,cols) * currElem;

				lineMapping[rows/mappingUintLength_bit] &= ~((mapType)0x01 << rows%mappingUintLength_bit);	
			}

			if(!(cols - 1))
			{
				for(int cnt(0);cnt < mappingArrayLength_byte; cnt ++)
				{lineMapping[cnt] = 0;}
			#if (SET_MEMORY_SOURCE == HEAP_MEMORY)	
				free(lineMapping);
				lineMapping = NULL;
			#endif
			}
		}
		return AlgebraicC;
	}
	
	
/* @brief:
	Define the member function of the determinant class*/
	
#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	operator=(determinant & det){
		if(detSize == det.detSize)
			determinantImport(det.elemArray);
	} 


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	bool determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	bool determinant<ELEM_TYPE>::
#endif
	operator==(determinant & det){
		int detLength = detSize * detSize;
		if(detSize == det.detSize)
		{
			int cnt(0); 
			for( ; cnt < detLength ; cnt ++)
			{
				if(elemArray[cnt] != det.elemArray[cnt])
					break;	
			}
			if(cnt == detLength)
				return true;
		}
		return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detRowSwap(int rows_s,int rows_d){
		ELEM_TYPE tmp;
		int basePs = rows_s * detSize,basePd = rows_d * detSize;
		for(int cnt(0) ; cnt < detSize ; cnt ++)
		{
			tmp = elemArray[basePs + cnt];
			elemArray[basePs + cnt] = elemArray[basePd + cnt];
			elemArray[basePd + cnt] = tmp; 
		}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detColSwap(int cols_s,int cols_d){
		ELEM_TYPE tmp;
		int basePs = cols_s,basePd = cols_d;
		for(int cnt(0) ; cnt < detSize ; cnt ++)
		{
			tmp = elemArray[basePs + cnt*detSize];
			elemArray[basePs + cnt*detSize] = elemArray[basePd + cnt*detSize];
			elemArray[basePd + cnt*detSize] = tmp; 
		}	
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif	
	detRowScalarMultiply(int rows,ELEM_TYPE num){
		int basePs = rows * detSize;
		for(int cnt(0) ; cnt < detSize ; cnt ++)
		{elemArray[basePs + cnt] *= num;}		
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detColScalarMultiply(int cols,ELEM_TYPE num){
		int basePs = cols;
		for(int cnt(0) ; cnt < detSize ; cnt ++)
		{elemArray[basePs + cnt*detSize] *= num;}	
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int determinant_size_row, int determinant_size_col>
	void determinant<ELEM_TYPE, determinant_size_row, determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detRowScalarDivide(int rows, ELEM_TYPE num){
		int basePs = rows * detSize;
		for (int cnt(0); cnt < detSize; cnt++)
		{elemArray[basePs + cnt] /= num;}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int determinant_size_row, int determinant_size_col>
	void determinant<ELEM_TYPE, determinant_size_row, determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detColScalarDivide(int cols, ELEM_TYPE num){
		int basePs = cols;
		for (int cnt(0); cnt < detSize; cnt++)
		{elemArray[basePs + cnt*detSize] /= num;}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detRowAdd(int rows_s,int rows_d){
		int basePs = rows_s * detSize,basePd = rows_d * detSize;
		for(int cnt(0) ; cnt < detSize ; cnt ++)
		{
	 		elemArray[basePd + cnt] += elemArray[basePs + cnt];
		}		
	}
	
	
#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	void determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
#endif
	detColAdd(int cols_s,int cols_d){
		int basePs = cols_s,basePd = cols_d;
		for(int cnt(0) ; cnt < detSize ; cnt ++)
		{
			elemArray[basePd + cnt*detSize] += elemArray[basePs + cnt*detSize];
		}	
	}
	
	
#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	ELEM_TYPE determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	ELEM_TYPE determinant<ELEM_TYPE>::
#endif
	getAlgebraicComplement(int rows,int cols){
	#if (SET_MEMORY_SOURCE == STACK_MEMORY)
		determinant<ELEM_TYPE, determinant_size_row - 1, determinant_size_col - 1> tmpDet;
	#else 
		determinant<ELEM_TYPE> tmpDet(detSize - 1,detSize - 1);
	#endif

		getComplementMinor(rows,cols,tmpDet);

		return tmpDet.getDeterminantValue() * (((rows + cols) & 0x01) ? -1 : 1);
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE,int determinant_size_row,int determinant_size_col>
	ELEM_TYPE determinant<ELEM_TYPE,determinant_size_row,determinant_size_col>::
#else
	template <class ELEM_TYPE>
	ELEM_TYPE determinant<ELEM_TYPE>::
#endif	
	getDeterminantValue(){
		ELEM_TYPE detValue(0);
		if (detSize > 2)
		{
			for (int cnt(0); cnt < detSize; cnt++)
			{
				detValue += elemArray[cnt * detSize] * detACCoreOperator(*this, cnt, 0) * ((cnt & 0x01) ? -1 : 1);
			}
		}
		else if(detSize == 2)
		{
			detValue = elemArray[0] * elemArray[3] - elemArray[1] * elemArray[2];
		}
		else detValue = elemArray[0];
		
		return detValue;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int determinant_size_row, int determinant_size_col>
	void determinant<ELEM_TYPE, determinant_size_row, determinant_size_col>::
	getTransposedDeterminant(determinant<ELEM_TYPE, determinant_size_row, determinant_size_col> & retDet)
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
	getTransposedDeterminant(determinant<ELEM_TYPE> & retDet)
#endif	
	{
		for (int cnt(0); cnt < detSize; cnt++)
		{
			for (int cnt2(0); cnt2 < detSize; cnt2++)
			retDet.elemArray[cnt2 * detSize + cnt] = elemArray[cnt * detSize + cnt2];
		}
		return retDet;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int determinant_size_row, int determinant_size_col>
	void determinant<ELEM_TYPE, determinant_size_row, determinant_size_col>::
	getComplementMinor(int rows, int cols,determinant<ELEM_TYPE, determinant_size_row - 1, determinant_size_col - 1> & retDet)
#else
	template <class ELEM_TYPE>
	void determinant<ELEM_TYPE>::
	getComplementMinor(int rows, int cols,determinant<ELEM_TYPE> & retDet)
#endif	
	{
		ELEM_TYPE * basePtr = retDet[0];
		int detPtr(0);
		for (int cnt(0); cnt < detSize; cnt++)
		{
			if (cnt == rows) { continue; }
			for (int cnt2(0); cnt2 < detSize; cnt2++)
			{
				if (cnt2 == cols) { continue; }
				basePtr[detPtr++] = elemArray[cnt * detSize + cnt2];
			}
		}
	}
};

/** 
  * @}
  */


/***************************************************************************************************
*	@defgroup matrix class library definition area
*	@{
***************************************************************************************************/

/* @CONTRAIL MATRIX LIBRARY:
	Definition of matrix class */
namespace CONTRAIL_MATRIX
{
/* @brief:
	Define the member function of the matrix class*/

#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	void matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	void matrix<ELEM_TYPE>::
#endif	
	matScalarMultiply(ELEM_TYPE num){
		for (int cnt(0); cnt < matrixDescription.matSizeRow * matrixDescription.matSizeCol; cnt++)
		{matrixDescription.pElemArray[cnt] *= num;}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	void matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	void matrix<ELEM_TYPE>::
#endif	
	matScalarDivide(ELEM_TYPE num){
		for (int cnt(0); cnt < matrixDescription.matSizeRow * matrixDescription.matSizeCol; cnt++)
		{matrixDescription.pElemArray[cnt] /= num;}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	bool  matrix<ELEM_TYPE>::
#endif	
	matMultiply(MATRIX mulMat, MATRIX retMat){
		if (((MATRIX_DES*)mulMat)->matSizeRow == matrixDescription.matSizeCol
		&&  ((MATRIX_DES*)retMat)->matSizeRow == matrixDescription.matSizeRow
		&&  ((MATRIX_DES*)retMat)->matSizeCol == ((MATRIX_DES*)mulMat)->matSizeCol)
		{
			for (int rows(0); rows < ((MATRIX_DES*)retMat)->matSizeRow; rows++)
			{
				for (int cols(0); cols < ((MATRIX_DES*)retMat)->matSizeCol; cols++)
				{
					ELEM_TYPE tmp(0);
					for (int cnt(0); cnt < matrixDescription.matSizeCol; cnt++)
					{
						tmp += matrixDescription.pElemArray[rows * matrixDescription.matSizeCol + cnt]
						* ((MATRIX_DES*)mulMat)->pElemArray[cnt * ((MATRIX_DES*)mulMat)->matSizeCol + cols];
					}
					((MATRIX_DES*)retMat)->pElemArray[rows * ((MATRIX_DES*)mulMat)->matSizeCol + cols] = tmp;
				}
			}
			return true;
		}
		else return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	bool matrix<ELEM_TYPE>::
#endif	
	matAdd(MATRIX addMat){
		if(matrixDescription.matSizeRow == ((MATRIX_DES*)addMat)->matSizeRow
		&& matrixDescription.matSizeCol == ((MATRIX_DES*)addMat)->matSizeCol)
		{
			for (int cnt(0); cnt < matrixDescription.matSizeRow * matrixDescription.matSizeCol; cnt++)
			{
				matrixDescription.pElemArray[cnt] += ((MATRIX_DES*)addMat)->pElemArray[cnt];
			}
			return true;
		}
		else return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	bool matrix<ELEM_TYPE>::
#endif	
	matSub(MATRIX subMat){
		if(matrixDescription.matSizeRow == ((MATRIX_DES*)addMat)->matSizeRow
		&& matrixDescription.matSizeCol == ((MATRIX_DES*)addMat)->matSizeCol)
		{
			for (int cnt(0); cnt < matrixDescription.matSizeRow * matrixDescription.matSizeCol; cnt++)
			{
				matrixDescription.pElemArray[cnt] -= ((MATRIX_DES*)subMat)->pElemArray[cnt];
			}
			return true;
		}
		else return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	void matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	void matrix<ELEM_TYPE>::
#endif	
	matRowScalarMultiply(int rows, ELEM_TYPE num){
		for (int cnt(0); cnt < matrixDescription.matSizeCol; cnt++)
		{
			matrixDescription.pElemArray[rows * matrixDescription.matSizeCol + cnt] *= num;
		}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	void matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	void matrix<ELEM_TYPE>::
#endif	
	matRowScalarDivide(int rows, ELEM_TYPE num){
		for (int cnt(0); cnt < matrixDescription.matSizeCol; cnt++)
		{
			matrixDescription.pElemArray[rows * matrixDescription.matSizeCol + cnt] /= num;
		}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	void matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	void matrix<ELEM_TYPE>::
#endif	
	matRowSwap(int rows_s, int rows_d){
		ELEM_TYPE tmp;
		int basePs = rows_s * matrixDescription.matSizeCol, basePd = rows_d * matrixDescription.matSizeCol;
		for (int cnt(0); cnt < matrixDescription.matSizeCol; cnt++)
		{
			tmp = matrixDescription.pElemArray[basePs + cnt];
			matrixDescription.pElemArray[basePs + cnt] =
				matrixDescription.pElemArray[basePd + cnt];

			matrixDescription.pElemArray[basePd + cnt] = tmp;
		}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	void matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	void matrix<ELEM_TYPE>::
#endif	
	matRowAdd(int rows_s, int rows_d){
		int basePs = rows_s * matrixDescription.matSizeCol, basePd = rows_d * matrixDescription.matSizeCol;
		for (int cnt(0); cnt < matrixDescription.matSizeCol; cnt++)
		{
			matrixDescription.pElemArray[basePd + cnt] +=
				matrixDescription.pElemArray[rows_s + cnt];
		}
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
	getDeterminant(determinant<ELEM_TYPE, matrix_size_row, matrix_size_col> & retDet)
#else
	template <class ELEM_TYPE>
	bool matrix<ELEM_TYPE>::
	getDeterminant(determinant<ELEM_TYPE> & retDet)
#endif	
	{
		if (matrixDescription.matSizeRow == matrixDescription.matSizeCol)
		{
			retDet.determinantImport(matrixDescription.pElemArray);
			return true;
		}
		return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	bool matrix<ELEM_TYPE>::
#endif	
	getInverseMatrix(MATRIX retMat){
		if (matrixDescription.matSizeRow == matrixDescription.matSizeCol)
		{
			ELEM_TYPE detVal = getDeterminantValue();
			if (detVal)
			{
				getAdjointMatrix(retMat);

				for (int cnt(0); cnt < ((MATRIX_DES*)retMat)->matSizeRow * ((MATRIX_DES*)retMat)->matSizeCol; cnt++)
				{
					((MATRIX_DES*)retMat)->pElemArray[cnt] /= detVal;
				}
				return true;
			}return false;
		}
		return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	bool matrix<ELEM_TYPE>::
#endif	
	getAdjointMatrix(MATRIX retMat){
		if(matrixDescription.matSizeRow == matrixDescription.matSizeCol
		&& ((MATRIX_DES*)retMat)->matSizeRow == matrixDescription.matSizeRow
		&& ((MATRIX_DES*)retMat)->matSizeCol == matrixDescription.matSizeCol)
		{
			for(int rows(0); rows < matrixDescription.matSizeRow; rows++)
			{
				for(int cols(0); cols < matrixDescription.matSizeCol; cols++)
				{
					((MATRIX_DES*)retMat)->pElemArray[rows * matrixDescription.matSizeCol + cols] =
					getAlgebraicComplement(cols,rows);
				}
			}
			return true;
		}
		else return false;
	}


#if (SET_MEMORY_SOURCE == STACK_MEMORY)
	template <class ELEM_TYPE, int matrix_size_row, int matrix_size_col>
	bool matrix<ELEM_TYPE, matrix_size_row, matrix_size_col>::
#else
	template <class ELEM_TYPE>
	bool matrix<ELEM_TYPE>::
#endif	
	getTransposeMatrix(MATRIX retMat){
		if (matrixDescription.matSizeRow == matrixDescription.matSizeCol)
		{
			for (int cnt(0); cnt < matrixDescription.matSizeRow; cnt++)
			{
				for (int cnt2(0); cnt2 < matrixDescription.matSizeRow; cnt2++)
				{
					((MATRIX_DES*)retMat)->pElemArray[cnt2 * matrixDescription.matSizeRow + cnt] = elemArray[cnt * matrixDescription.matSizeRow + cnt2];
				}
			}
			return true;
		}
		return false;
	}
}

/**
  * @}
  */

#endif
